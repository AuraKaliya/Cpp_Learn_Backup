

# 《C++ Core Guidelines》学习笔记

## 概要

本文档的目标是帮助开发者采用现代 C++（目前是 C++20 和 C++17），并在各个代码库之间达成更加统一的编码风格。

这本书所关注的是一些相对高层次的问题，比如接口，资源管理，内存管理，以及并发等等。

强调静态类型安全性和资源安全性。

避免对 `nullptr` 解引用，避免悬挂指针，以及（通过 RAII）系统性地使用异常的可能性。

消除一些规则的违背：

* **type**: 消除类型违规（如通过强制转换（cast），联合体（union），或者变参（varargs）把 `T` 重解释为 `U`）
* **bounds**: 消除边界违规（如越过数组范围的访问）
* **lifetime**: 消除泄漏（如未能 `delete` 或者进行多次 `delete`），以及消除对无效对象的访问（如解引用 `nullptr`，或使用悬挂引用）。

## 一些观点

**一般性规则可以很简单，但却没办法强制实施。**

**不要把可以在编译期搞定的事推后到运行时进行。**

**力求高效的另一种好处是，这一过程将强迫你更深入地理解问题。**

**接口应当是函数或函数的集合。**



## 内容



```c++
[[gsl::suppress(tag)]]   
[[gsl::suppress(tag, justification: "message")]]

//用于编译器对程序代码的强制实施消除警告
//tag可替换为type.1 或 bounds

//[[gsl::suppress(bounds.1, justification: “这里的指针算术是安全的”)]] { int* p = arr + 1; // 这里不会报告警告，并且会显示理由 }
```



### 理念

通常，理念性的规则都无法机械性地进行检查。不过，这些理念主题在各个规则中都有体现。

* **在代码中直接表达你的想法**

    代码中所表达的东西是带有**明确的语义**的，并且（原则上）是可以由编译器和其他工具进行检验的。

    1.数据定义时

```c++
//数据定义时

class Date {
public:
    Month month() const;  // 好
    int month();          // 不好
    // ...
};
//`month` 的第一个声明式，显然是要返回一个 `Month`，而且不会修改 `Date` 对象的状态。
//而第二个版本则需要读者进行猜测，同时带来了更多的出现难于发现 BUG 的可能性。

```

​	2.程序结构的设计时

```c++
//程序结构的设计时

//一个查找字符串的示例
void f(vector<string>& v)
{
    string val;
    cin >> val;
    // ...
    int index = -1;                    // 不好，而且应该使用 gsl::index
    for (int i = 0; i < v.size(); ++i) {
        if (v[i] == val) {
            index = i;
            break;
        }
    }
    // ...
}

/*gsl::index 是一个用于表示所有容器索引/下标/大小的索引类型的别名，它等同于 std::ptrdiff_t。它的作用是让静态代码分析工具和人类读者清楚地知道一个有损转换是可以接受的。
例如：
int x = v[gsl::index(0)]; // 使用 gsl::index 明确表示索引类型
这样可以避免一些潜在的问题，比如隐式地将无符号整数转换为有符号整数，或者将较大的整数类型转换为较小的整数类型
*/

//将循环体改为
 auto p = find(begin(v), end(v), val); 
//拥有明确的带有功能性的函数，也简洁了程序的结构。

```

​	3.函数设计和使用时

```c++
//参数设计
change_speed(double s);   // bad: s 代表什么？
change_speed(Speed s);    // 好多了：说明了 s 的含义

//或者，传入double speed 说明传入的值代表的含义是speed

```

* **用 ISO 标准 C++ 来编码**

    有些环境下是**需要使用语言扩展的**，例如有关访问系统资源的语言扩展。
    这些情况下，应当将对所需语言扩展的使用局部化，并把它们的使用置于非核心的编码指导方针的控制之下。如果可能的话，应当构建一些**接口**来封装这些语言扩展，**以使其能够被关闭**，并当针对不支持这些语言扩展的系统时免除它们的编译。

    应当避免依赖于未定义的行为。

    **强制实施方案**：使用最新版的 C++ 编译器（目前支持 C++20 或 C++17），并打开禁用语言扩展的选项。

* **表达你的设计意图**

    一些代码如果不（比如通过命名或者代码注释）说明其设计意图的话，是不可能搞清楚代码是否达成其预定目标的。

    1. while循环访问容器，在循环体外部定义控制变量（意图和实际设计的变量的生存期与作用域存在差异）

    ```c++
    gsl::index i = 0;
    while (i < v.size()) {
        // ... 在 v[i] 上做一些事 ...
    }
    
    //i的生存期明显超过实际执行的作用域对应的生存期，可能导致在其他地方被误用
    
    //更好的方式：
    for (const auto& x : v) { /* 用 x 的值做一些事 */ }
    //或者
    for (auto& x : v) { /* 修改 x */ }
    
    //在结构上表明意图，同时也需要在注释上解释功能模块。
    ```

* **理想情况下，程序应当是静态类型安全的**

    当编码时触及到存在这方面风险的区域时，应当时刻注意。

    * `union`
    * 强制转换
    * 数组退化
    * 范围错误
    * 窄化转换

    1. 对于union的替代，可以使用variant(C++17提供)，

        variant可用于实现多态，给根据不同的数据类型执行不同的操作。

        ```c++
        #include <iostream>
        #include <variant>
        
        // 定义一个variant类型，可以存储int, double或std::string
        using var_t = std::variant<int, double, std::string>;
        
        // 定义一个访问者类，重载了operator()，可以处理不同类型的参数
        struct Visitor {
            void operator()(int i) {
                std::cout << "整数: " << i << "\n";
            }
            void operator()(double d) {
                std::cout << "浮点数: " << d << "\n";
            }
            void operator()(const std::string& s) {
                std::cout << "字符串: " << s << "\n";
            }
        };
        
        int main() {
            // 创建一个variant对象，初始值为42
            var_t v = 42;
            
            // 使用std::visit调用Visitor类的实例，根据v中的值的类型选择合适的重载
            std::visit(Visitor{}, v);
        
            // 修改v的值为3.14
            v = 3.14;
        
            // 再次使用std::visit调用Visitor类的实例
            std::visit(Visitor{}, v);
        
            // 修改v的值为"hello"
            v = "hello";
        
            // 再次使用std::visit调用Visitor类的实例
            std::visit(Visitor{}, v);
        
            return 0;
        }
        ```

        variant实现的是一个类型安全的联合(union)，保证每次只会存在一种类型的数据，并可以检查当前存储的数据类型。

        variant可以用于实现可选值，即在没有确定值的情况下，可以使用std::monostate作为默认类型。

    2. 尽可能减少强制转换的使用，更多地采用模板可以帮助到这一点。

    3. 使用span来应对数组退化和范围错误问题

        **数组退化**是指在将数组作为函数参数传递时，数组会自动转换为指针，从而**丢失了数组的大小信息**。这会导致一些问题，比如无法在函数内部正确地遍历数组，或者无法对数组进行范围检查，防止**越界访问**。

        span是一种可以存储多种类型的数据的容器，它类似于union，但是更加安全和灵活。span可以接收一个数组或一个指针和一个大小作为构造参数，然后创建一个对应原始数据的**视图(**View)，**不会复制数据**。同时，span可以像**vector**一样使用下标运算符、迭代器、size等来**访问和操作数据**。除此之外，span可以**用于实现类型安全的联合**，即**在任何时候只能存储其中一种类型的数据**，并且可以检查和获取当前存储的数据类型。

        span可以用于实现可选值，即在没有确定值的情况下，可以使用**std::monostate**作为默认类型。

    4. **尽可能减少窄化转换的使用**，如因为逻辑功能的实现（四舍五入等）必须使用时则使用 `narrow` 或者 `narrow_cast`。

* **编译期检查优先于运行时检查**

    为了代码清晰性和性能。
    对于编译期识别的错误是不需要编写错误处理的。

    **不要把可以在编译期搞定的事推后到运行时进行**。

    ```c++
    //这段需要保证运行时输入的数据的正确性，需要考虑边界问题。
    void read(int* p, int n);   // 读取至多 n 个整数到 *p 之中
    
    int a[100];
    read(a, 1000);    // 不好，超过末尾了
    
    
    //这段并不需要保证，因为传入的数据只有a，不需要考虑数组越界问题。
    void read(span<int> r); // 读取到整数区域范围 r 之中
    
    int a[100];
    read(a);        // 好多了: 让编译器确定元素数量
    
    ```

* **应当使无法在编译期进行的检查能够在运行时实施**

    对应一个软件工程的原则：错误越早发现其修改成本越小。

    1. 参数的跨函数传递时，需要保证其所含内容不丢失。

    ```c++
    
    //数据的部分信息丢失
    // 分离编译，可能会被动态加载
    extern void f(int* p);
    
    void g(int n)
    {
        // 不好的：并未把元素数量传递给 f()
        f(new int[n]);
    }
    
    //数据传递存在明显的使用隐患
    // 分离编译，可能会被动态加载
    extern void f2(int* p, int n);
    
    void g2(int n)
    {
        f2(new int[n], m);  // 不好的：可能会把错误的元素数量传递给 f()
    }
    
    
    //数据传递后的后续处理的方法给写死了
    // 分离编译，可能会被动态加载
    // NB: 这里假定调用代码是 ABI 兼容的，使用的是
    // 兼容的 C++ 编译器和同一个 stdlib 实现
    extern void f3(unique_ptr<int[]>, int n);
    
    void g3(int n)
    {
        f3(make_unique<int[]>(n), m);    // 不好的：把所有权和大小分开进行传递
    }
    
    
    //extern作为表示该变量或函数进行全局化定义，将其他文件的该变量或函数的作用域扩展到全局。
    
    //得把指针和元素数量作为一个对象整体来进行传递：
    extern void f4(vector<int>&);   // 分离编译，可能会被动态加载
    extern void f4(span<int>);      // 分离编译，可能会被动态加载
                                    // NB: 这里假定调用代码是 ABI 兼容的，使用的是
                                    // 兼容的 C++ 编译器和同一个 stdlib 实现
    
    void g3(int n)
    {
        vector<int> v(n);
        f4(v);                     // 传递引用，保留所有权
        f4(span<int>{v});          // 传递视图，保留所有权
    }
    
    //这个设计将元素数量作为对象的固有部分，因此不太可能有错误，动态（运行时的）检查即使不总是可承担的，也总是可行的。
    ```

* **尽早识别运行时错误**

    需要避免程序崩溃，也需要避免会产生错误结果的程序错误。

    在函数调用时（更上一级程序结构中）发现错误比在函数内发现错误更好（比如传递参数，在函数体内进行循环，在传参设计上就进行检查显然比在函数体内检查出错误更好）。

    不要对同一个值重复进行检查。不要用字符串来传递有结构的数据。

    ```c++
    Date read_date(istream& is);    // 从 istream 读取日期
    
    Date extract_date(const string& s);    // 从 string 中抽取日期
    
    void user1(const string& date)    // 操作 date
    {
        auto d = extract_date(date);
        // ...
    }
    
    void user2()
    {
        Date d = read_date(cin);
        // ...
        user1(d.to_string());
        // ...
    }
    //这个日期被（`Date` 的构造函数）验证了两次，并以字符串（无结构的数据）的形式来传递。
    //这是需要避免的
    ```

* **不要泄漏任何资源**

    即使是缓慢的资源增长，随着时间推移，也会耗尽这些资源的可用性。这对于长时间运行的程序来说尤其重要。

    ```c++
    void f(char* name)
    {
        FILE* input = fopen(name, "r");
        // ...
        if (something) return;   // 不好的：如果 something == true 的话，将会泄漏一个文件句柄
        // ...
        fclose(input);
    }
    
    //相对的，采用RAII
    void f(char* name)
    {
        ifstream input {name};
        // ...
        if (something) return;   // OK: 没有泄漏
        // ...
    }
    ```

* 不要浪费时间或空间

    你用的语言是 C++。

    力求高效的另一种好处是，这一过程将强迫你更深入地理解问题。

    ```c++
    void lower(zstring s)
    {
        for (int i = 0; i < strlen(s); ++i) s[i] = tolower(s[i]);
    }
    //可以看到这里有一句 `i < strlen(s)`。这个表达式在循环的每次重复中都要求值，这意味着每次循环中 `strlen` 都必须走完字符串以确定其长度。我们假定在改动字符串内容过程中`tolower` 不会影响字符串的长度，因此最好在循环外面缓存长度值，而不是在每次重复中都承担其代价。
    
    //更加具体的 ++i和i++
    ```

* **不可变数据优先于可变数据**

    对常量进行推理要比变量简单得多。
    不可变的事物是不可能被意外改变的。

    在常量上不会出现数据竞争。

* **把杂乱的构造封装起来，而别让其散布到代码中**

    方法：查找如复杂指针操作和在抽象的实现外面进行强制转换这样的“混乱代码”。

    标准库和 GSL 都是这种理念的例子。
    例如，我们并不使用混乱的数组，联合体，强制转换，麻烦的生存期问题，`gsl::owner`，等等，
    它们用于实现一些关键抽象，诸如 `vector`，`span`，`lock_guard`，以及 `future`，我们使用的是
    一般来说比我们有更多时间和专业能力的人所设计和实现的程序库。
    类似地，我们也能够而且应该设计并实现更专门的程序库，而不是将其留给用户（通常是我们自己）
    来面对需要重复把低级代码搞正确的挑战。

    **使用容器替代一般数据要进行的复杂数据操作和安全检查。**



## 接口

接口是程序中两个模块之间的契约，良好的接口需要易于理解、高效的使用方式、支持进行测试等。

* **接口需要明确**

    未在接口中规定的假设很容易被忽视且难于测试。

    通过非局部变量进行的报告经常被忽略。

    ```c++
    fprintf(connection, "logging: %d %d %d\n", x, y, s);
    //fprintf的返回值未进行检查，可能会因为链接关闭而导致没有日志输出产生。
    //替代方案：抛出异常
    ```

    接口应当是函数或函数的集合。

* **避免非const全局变量**

    非const全局变量能够隐藏依赖关系，并且使这些依赖项产生无法预测的变动。

    如果用全局数据来避免复制操作时，一般考虑把数据以const引用的形式进行传递的方案。

* **避免使用单例**

    单例基本上是经过伪装的更复杂的全局对象。

    ```c++
    class Singleton {
     // ... 大量代码，用于确保只创建一个 Singleton，
     // 进行正确地初始化，等等
    };
    
    //如果不想让全局对象被改变，请将其声明为 const 或 constexpr。
    //或者使用最简单的单例
    X& myX()
    {
     static X my_x {3};
     return my_x;
    }
    //在多线程环境中，静态对象的初始化并不会引入数据竞争条件
    //但如果使用指针，则需要考虑指针泄漏的问题（多线程中访问）
    X& myX()
    {
     static auto p = new X {3};
     return *p; // 有可能泄漏
    }
    ```

* **使接口严格和强类型化**

    类型是最简单和最好的文档，它们有定义明确的含义并因而提高了易读性，并且是在编译期进行检查的。

    ```c++
    //所以，应当避免以下方式：
    void pass(void* data); // 使用弱的并且缺乏明确性的类型 void*是有问题的
    //调用者无法确定它允许使用哪些类型，而且因为它并没有指定 const，也不确定其数据是否会被改动。
    //任何指针类型都可以隐式转换为void*，所以它很容易被赋值。
    //被调用方必须以 static_cast 将数据强制转换为某个无验证的类型以使用它。
    
    //请考虑使用 variant 或指向基类的指针来代替它。
    //通常，利用模板形参可以把 void* 排除而改为 T* 或者 T&。
    ```

    **使用enum/variant替代多个布尔值出现的情况。**

* **说明前条件（如果有）**

    参数上蕴含着使它们在被调用方中能够恰当使用的约束关系。

    ```c++
    double sqrt(double x);
    
    //这里 x 必须是非负数。类型系统是无法（简洁并自然地）表达这点的，因而我们得用别的方法。
    
    double sqrt(double x); // x 必须是非负数
    
    double sqrt(double x) { Expects(x >= 0); /* ... */ }
    
    //条件表达式是一个布尔值，表示期望的前提条件。
    ```

    **Expects**是C++中用于表达前提条件的一个宏，它是C++标准库中的一部分，属于**契约编程**的范畴。Expects可以用来**检查一个函数的参数是否满足一定的要求**，如果不满足，就会抛出一个异常或者终止程序。Expects的好处是可以提高代码的**可读性**和健壮性，**避免出现未定义行为或者隐含的错误**。

* **优先使用Expects()来表达前条件**

    清晰地表明这个条件是一个前条件，并便于工具的利用。

    ```c++
    //Expects() 与 if() 的使用对比
    
    int area(int height, int width)
    {
     Expects(height > 0 && width > 0); // 好
     if (height <= 0 || width <= 0) my_error(); // 隐晦的
     // ...
    }
    
    //前条件是可以用许多方式来说明的，包括代码注释，if 语句，以及assert()。
    //Expects和C语言中的assert有一些相似之处，但也有一些区别。assert只在调试模式（定义了NDEBUG宏）下有效，而Expects在任何模式下都有效。assert只能终止程序，而Expects可以根据编译器的设置抛出不同类型的异常。assert只能检查静态条件（编译确定），而Expects可以检查动态条件（运行确定）。
    ```

* **说明后条件**

    在数据处理产生结果后，应对处理结果的正确性和安全性负责。

    ```c++
    int area(int height, int width) { return height * width; } // 不好
    //未规定传入参数大于0	（前条件）
    //未判定返回结果是否溢出   （后条件）
    
    int area(int height, int width)
    {
     auto res = height * width;
     Ensures(res > 0);
     return res;
    }
    ```

    关于说明后条件的重要性，这里有一个著名的安全性BUG：编译器自主优化。

    ```c++
    void f() // 有问题的
    {
     char buffer[MAX];
     // ...
     memset(buffer, 0, sizeof(buffer));
    }
    //由于没有后条件来说明缓冲区应当被清零，优化器可能会将这个看似多余的 memset() 调用给清除掉
    void f() // 有改进
    {
     char buffer[MAX];
     // ...
     memset(buffer, 0, sizeof(buffer));
     Ensures(buffer[0] == 0);
    }
    //后条件通常是在说明函数目的的代码注释中非正式地进行说明的；用Ensures() 可以使之更加系统化，更加明显，并且更容易检查。
    //所以优先使用 Ensures() 来表达后条件。
    ```

* **当接口是模板时，用概念来文档化其参数**

    更严谨地说明接口，并使其在（不远的）将来可以在编译时进行检查。

    ```c++
    template<typename Iter, typename Val>
     requires input_iterator<Iter> &&
    equality_comparable_with<iter_value_t<Iter>, Val>
    Iter find(Iter first, Iter last, Val v)
    {
     // ...
    }
    
    //在模板定义后面添加必要的条件说明，严格限制模板的数据处理逻辑。
    
    /*
    requires是一段要求子句，表示函数模板参数必须满足子句后的概念。
    input_iterator<Iter> 表示Iter必须为输入迭代器，不能修改容器的元素。
    equality_comparable_with<iter_value_t<Iter>, Val>表示传入的iter_value_t<Iter>和Val必须是课比较的。
    iter_value_t<Iter>表示由Iter迭代器所指向的元素的值。
    */
    
    /*
    在要求子句中，一般分为简单要求、类型要求、复合要求和嵌套要求。
    简单要求：是一个可以求值为布尔值的表达式，用于检查某个类型是否支持某个操作或者具有某个属性。
    std::copyable<T>;   //表示T是可复制的，支持拷贝构造函数和拷贝赋值运算符。
    类型要求：是一个用关键字 typename 开头的类型名，用于检查某个类型是否存在或者是否符合某个形式。
    typename T::value_type;   //表示 T 必须有一个名为 value_type 的嵌套类型。
    复合要求：是用花括号括起来的一个表达式，后面跟着一个返回类型的要求，用箭头符号（->）表示。复合要求用于检查表达式的返回类型是否符合预期。
    { x + y } -> std::same_as<int>;    //表示 x + y 的返回类型必须和 int 相同。
    嵌套要求：是用关键字 requires 开头的一个布尔表达式，用于检查某个类型是否满足另一个概念
    概念和要求是C++20引入的新特性，用来约束模板参数的类型，以提高代码的可读性和安全性。
    */
    ```

* **使用异常来表明无法实施所要求的任**

    不应该让错误可以被忽略，因为这将导致系统或者一次运算进入未定义的（或者预料之外的）状态。

* **决不以原始指针（T*）或引用（T&）来传递所有权**

    如果对**调用者**和**被调用方**哪一个**拥有对象**有疑问，那就会造成泄漏或者发生提早的析构。

    ```c++
    X* compute(args) // 请勿这样做
    {
         X* res = new X{};
         // ...
         return res;
    }
    
    //应该考虑按值来返回结果（如果结果比较大的话就用移动语义）
    vector<double> compute(args) // 好的
    {
         vector<double> res(10000);
    	// ...
    	return res;
    }
    //或者，用“智能指针”来传递所有权，比如 unique_ptr（专有所有权）和shared_ptr（共享所有权）。
    //这样做会对性能和编码简洁性造成一定影响，所以，仅当需要引用语义时再使用智能指针。
    
    ```

* **把不能为空的指针声明为not_null**

    帮助避免对 nullptr 解引用的错误。

    通过避免多余的 nullptr 检查来提高性能。

    ```c++
    int length(not_null<const char*> p);//可以假定 p 不可能为 nullptr
    ```

* **不要只用一个指针来传递数组**

    (pointer, size) 式的接口是易于出错的。

    ```c++
    //考虑使用明确的 span：
    void copy(span<const T> r, span<T> r2); // 将 r 复制给 r2
    ```

* **优先以空抽象类作为类层次的接口**

    空的（**没有非静态成员数据**）抽象类要比**带有状态的基类**更倾向于保持稳定。

    ```c++
    class Shape { // 不好: 接口类中加载了数据
    public:
     Point center() const { return c; }
     virtual void draw() const;
     virtual void rotate(int);
     // ...
    private:
     Point c;
     vector<Point> outline;
     Color col;
    };
    
    //这将强制性要求每个派生类都要计算出一个中心点——即使这并不容易，而且这个中心点从不会被用到。
    
    
    class Shape { // 有改进: Shape 是一个纯接口
    public:
     virtual Point center() const = 0; // 纯虚函数
     virtual void draw() const = 0;
     virtual void rotate(int) = 0;
     // ...
     // ... 没有数据成员 ...
     // ...
     virtual ~Shape() = default; 
    };
    ```

    

* 

