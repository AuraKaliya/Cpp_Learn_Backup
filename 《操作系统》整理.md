# 操作系统整理

## 概述

操作系统具有的基本特性：并发、共享、虚拟、异步。除此之外，分时系统具有及时响应、实时系统具有实时特征、批处理系统具有高资源利用率和系统吞吐量。

* 并发和并行

    并行性是指两个或多个事件在**同一时刻发生**，并发性是指两个或多个事件在**同一时间间隔内**发生。

* 共享

    在操作系统环境下的资源共享也被称为**资源复用**，指系统中的资源可供内存中多个并发执行的进程共同使用。目前，主要的方式为：**互斥**的**共享**方式和**同时**的**访问**方式。

* 虚拟

    在操作系统中，把通过某种技术将一个**物理实体**变为若干个**逻辑上的对应物**的功能称为虚拟，通过**时分复用**和**空分复用**技术实现。

* 异步

    将**程序的执行分为多个阶段**，允许先入内存的后执行完毕的情况发生。



## 顺序执行与并发执行

* 程序的顺序执行

    * 特征

        顺序性：处理机按照程序规定的顺序执行，每个操作必须在下一个操作开始前结束。

        封闭性：程序在封闭的环境下运行，程序运行时独占所有资源。

        可再现性：复数次执行得到相同的结果。

    * 其他思考

        对检测和校验程序的正确性提供方便，也适合理清程序运行的逻辑。

        对系统资源的利用低。

* 程序的并发执行

    像输入和输出两种在使用资源上有区别的功能可进行并发执行，但同一阶段的输入输出必须是顺序逻辑的。（即功能节点是否具有前趋关系）

    * 特征

        间断性：并发执行的程序共享系统资源，但因调用条件而形成制约关系，具有执行-暂停-执行的间断性活动规律。

        失去封闭性：资源共享带来的是封闭性失去，程序获得资源的前提需要资源空闲能被占用。

        不可再现性：程序的执行结果与环境、初始条件、运行条件、处理机状态等相关，复杂性决定了不可再现性。

    

## 进程

* 定义

    因为并发执行的程序具有间断性、失去封闭性和不可再现性，在通常情况下是不能允许程序进行并发操作。所以，为了能够让程序并发执行，并且有一定手段控制和描述，所以引进了进程的概念。

    操作系统中通过专门的数据结构进程控制块（PCB）来描述程序的状态信息和进行管理，由程序段、数据段和PCB构成的进程实体称为进程。

    进程是程序的一次执行，是系统分配和调度资源的独立单位。

* 特征

    动态性：程序只是有序指令的集合，而进程实体具有一定的生命周期，它由创建而产生，由调度而执行，由撤销而消亡。

    并发性：多个进程实体同时存放在内存中，并能在一段时间内同时运行。程序不能并发，进程因有控制模块（PCB）可以并发。

    独立性：进程能作为独立运行、独立分配资源、独立接受调度的一个基本单位。

    异步性：进程按异步的方式运行，运行方式在进程自己处不可知，但PCB能通过对进程的状态信息的控制保证并发结果可再现。

    通过进程同步机制实现并发同步可再现性控制。

* 进程的状态和转换

    * 三种基本状态

        就绪状态：进程以获得除CPU外所有必需的资源后，进入的准备好运行的状态，通常按照优先级被操作系统放进就绪队列中。

        执行状态：进程已获得CPU，程序处于执行状态。

        阻塞状态：处于执行状态的进程由于某些事件发生而无法继续执行，随即进入阻塞状态，这个状态的转换引起资源调度，处理机被分配给另一个就绪进程，而该进程则进入阻塞队列中。

    * 两种始末状态

        创建状态：进程创建时，需要先创建一个PCB控制块，再为该进程分配资源。当资源不足时，进程的创建工作尚未完成，进程所处状态为创建状态。

        终止状态：进程的终止需要经过后续处理和PCB清除过程。

    * 挂起操作

        挂起操作由用户需要、系统需要和高级别进程请求（父进程）引起，对活动的进程（就绪、执行、阻塞）进行等待挂起，让进程进入静止状态，进程不会释放资源，但只接收特定的唤醒信号再度转换为活动状态才可继续执行逻辑。

## 操作系统用于管理的数据结构

操作系统中对于系统资源进行管理的数据结构分为以下四类：内存表、设备表、文件表和进程表。

* 进程表：PCB表，描述控制的进程模块和其使用的资源信息。

    * PCB的作用：

        作为独立运行的标志：系统通过PCB感知进程。

        实现间断运行方式：能够在中断程序时保存程序的信息。

        提供进程管理和调度所需信息：系统通过PCB控制进程。

        实现进程间通信和同步机制。

    * PCB主要内容

        进程标识符：提供用户或系统对进程访问的渠道。

        处理机状态：表示进程执行时的处理机状态的保存。

        进程调度信息：包括优先级、调度算法、进程状态等。

        进程控制信息：包括进程内程序和数据地址、同步机制和通信机制的实现等。

    * PCB的组织方式

        线性、指针链表、索引表方式。

    

    

## 操作系统内核

操作系统通常将设备的驱动程序、使用频率较高的模块给安排在仅靠硬件的软件层次中，将它们常驻与内存里，通常被称为OS内核。

* 用户态和内核态：

    处理机的状态通常被分为两态：

    * 用户态：又称目态，具有较低的执行特权，一般程序在此运行。
    * 内核态：又称管态，能够执行一切指令，具有较高的特权。

* 内核的支撑功能
    * 中断处理：各种类型的系统调用都依赖于中断处理。
    * 时钟管理：用于产生计时信号。
    * 原语操作：由若干条指令组成的**原子操作**，要么做完，要么不做。作为一个不可分割的指令集操作。











## 进程同步

为了保证多个进程有条不紊地运行，在多道程序系统中，必须引入**进程同步机制**。

* 进程同步的两种制约关系

    间接制约：进程向系统申请**临界资源**必须要**互斥**地访问。

    直接制约：对于从**同一内存区域进行存读**的程序，需要协调程序的**执行次序**。

* 生产者-消费者问题

    生产者向缓冲区内生产产品，消费者通过从缓冲区内取走产品进行消费。不允许消费者进入空缓冲区拿产品，也不允许生产者向满缓冲区生产产品。

    在处理时，应考虑令生产者和消费者互斥地访问缓冲区余量的变量。
    
* 处理进程同步的方法

    * 锁机制

        加锁关中断，原子访问，其余进程进行询问锁空闲。

    * 信号量机制

        对资源设置信号量状态以确定能否访问。

    * 管程机制

        通过一个公有的数据结构对进程所需的资源进行访问，管程中维护了一个等待队列用于管理并发程序对同一资源的访问，通过原语信号进行进程的唤醒和阻塞。



## 进程通信

进程间的通信是服务于进程的同步与互斥机制的。

* 进程通信的类型

    * 共享存储器系统

        需要通信的进程共享一块内存区域，对需要共享的数据从共享内存区进行申请内存并使用，内存区仅对其进行引用计数。

    * 管道通信系统

        通过一个pipe共享文件连接写进程和读进程之间的通信。

        管道通信需要满足三个标准：**互斥等待**（读/写时另一方需要等待）、**同步通信**（写入最大值进入等待，读空值进入等待）、**明确存在**（明确对方存在，保证有读和写一对进程同时存在）

    * 消息传递系统

        利用操作系统提供的通信原语，通过一组格式化的消息在进程间进行传递，通常分为两类：直接消息传递（send receive）和间接消息传递（邮箱作为消息载体，类似管道通信）(post read)。

    * 客户端-服务器系统

        套接字通信



## 线程

引入进程是为了多道程序并发执行，提高资源利用率；引入线程是为了减小程序并发处理时的时空开销。

* 进程的属性

    进程是可拥有资源的独立单位，是可独立调度和分派的基本单位。

    进程的开销主要体现在创建进程、撤销进程和进程切换。

* 线程的属性

    在引入线程的系统中，线程作为可独立调度和分派的基本单位。线程本身只拥有能保证独立运行的资源和一个控制用的线程控制块TCB，线程共享进程拥有的资源。

* 支持多线程OS中

    进程是一个可拥有资源的基本单位，多个线程可并发执行，进程已不是可执行的实体，而是描述线程执行状态的集合。

* 线程的实现

    线程通常有三种实现方式

    * 内核支持线程

        线程的创建、阻塞、撤销和切换在内核的支持下，于内核空间内实现。

        内核能调度同一进程中的多个线程并发执行，当一个线程被阻塞时，内核可调度该进程中的其他线程占用处理器。

        内核支持线程具有很小的数据结构和堆栈占用，控制的开销小。

        内核本身也可以采用多线程技术。

    * 用户支持线程

        用户级线程在用户空间内实现，对线程的控制也在用户空间内进行，内核并不关心用户级线程的状态。

        用户级线程的切换不需要进入内核空间，调度算法为进程专用，实现与OS平台无关。

        但是用户级线程存在系统阻塞的问题，当线程执行某一系统调用时，会阻塞的是拥有线程的进程。内核一次只能分配给一个进程的仅有一个CPU，所以本质上还是顺序调用的。

    * 组合使用

        通过**时分复用**技术实现用户级线程与内核支持线程的关联实现。

        通常有三类模型：一对一模型，多对一模型，多对多模型。



## 处理机调度

* 处理机调度层次

    处理机调度层次分为三类：高级调度（作业调度）、低级调度（进程调度）和中级调度（内存调度，进程挂起）。

* 处理机调度算法的共同目标

    * 提高CPU利用率。
    * 调度算法应尽可能公平，防止饥饿进程产生。
    * 对不同类型的进程（算法进程、IO进程），处理机对资源的分配应尽可能平衡。
    * 策略强制执行，需要有一个最高优先级的安全策略保证系统的稳定运行。

* 调度算法

    * 先来先服务（FCFS）

        维护一个就绪队列，系统按照作业到达的先后次序进行处理调度。

    * 短作业优先（SJF）

        维护一个优先队列，作业越短优先级越高。

    * 优先级调度算法（PSA）

        对优先级的确定有一套统一的算法，最常见的是动态等待优先级算法。

    * 轮转调度算法（RR）

        对可抢占的进程进行调度，维护一个时间片，每个进程执行一段时间片后进行抢占挂起。

* 

## 死锁问题

在系统中有许多不同类型的资源，其中可以引起死锁的主要为“互斥访问类”和“不可抢占类”资源。

资源一般分为可重用性和消耗性资源，也分为可抢占性和不可抢占性资源。

* 引起死锁的原因

    竞争不可抢占资源引起的循环等待。

    竞争可消耗资源引起的阻塞等待。

    进程推进不当导致系统进入不安全状态引起资源耗尽无法释放。

* 产生死锁的必要条件

    资源互斥、请求和保持、不可抢占、循环等待。

* 处理死锁

    预防、避免、检测、解除。

    