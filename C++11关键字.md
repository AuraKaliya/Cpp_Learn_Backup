# C++11关键字

## constexpr

```cpp
#include<iostream> 
#include<time.h>
using namespace std;
//在这个函数里面，由于constexpr稀释的是fib1这个函数，因此每一次计算的结果都会作为一个常量保存下来
constexpr long int fib1(int n)
{
    return (n <= 1) ? n : fib1(n - 1) + fib1(n - 2); //只能包含一个retrun语句
}
//熟悉递归函数就不难证明下面这个函数的时间复杂度为O(2^n)
long int fib2(int n) {
    return (n <= 1) ? n : fib2(n - 1) + fib2(n - 2);
}
int main()
{
    // value of res is computed at compile time. 
    clock_t start, end;
    start = clock();
    const long int res = fib1(42);
    end = clock();
    cout << "Totle Time fib1 : " << (double)(end - start) / CLOCKS_PER_SEC << "s" << endl;
    start = clock();
    const long int res2 = fib2(42);
    end = clock();
    cout << "Totle Time fib2 : " << (double)(end - start) / CLOCKS_PER_SEC << "s" << endl;
    cout << res2;
    return 0;
}
//输出：
/*
Totle Time fib1 : 1.977s
Totle Time fib2 : 2.159s
267914296
*/
```

## typedef

```c++
typedef <原有类型名> <新类型名>;
```

```c++
typedef int arr[10]; // 定义arr为含有10个整数的数组类型的别名

arr x, y, z; // 等价于int x[10], y[10], z[10];
```

```c++
typedef int * iptr; // 定义iptr为int *的别名

iptr a, b, c; // 等价于int *a, *b, *c;
```

```c++
typedef struct point {
    int x;
    int y;
} point; // 定义point为结构体类型的别名

point p; // 等价于struct point p;
```

```c++
typedef int (*func) (int, int); // 定义func为返回值为int，参数为两个int的函数指针类型的别名

func f = max; // 定义f为一个函数指针，并赋值为max函数

int result = f(3, 5); // 调用f指向的函数，并传入参数3和5
```

## using

```c++
typedef int MyInt; // 定义MyInt为int的别名
using MyInt = int; // 与上面等价
```

```c++
template <typename T>
using MyVector = std::vector<T>; // 定义MyVector为一个模板别名，表示一个向量类型

MyVector<int> v; // 等价于std::vector<int> v;
```

```c++
typedef void (*Func) (int, int); // 定义Func为一个函数指针类型
using Func = void (*) (int, int); // 与上面等价，但更容易理解

typedef int (&Arr) [10]; // 定义Arr为一个数组引用类型
using Arr = int (&) [10]; // 与上面等价，但更容易理解
```

## decltype

作用是根据一个表达式的类型来推导出一个变量的类型。

```c++
decltype(expression) variable;
```

```c++
int a = 10; //a是int类型
decltype(a) b = 20; //b也是int类型，因为decltype(a)推导出int
double c = 3.14; //c是double类型
decltype(c + 1) d = 4.56; //d也是double类型，因为decltype(c + 1)推导出double
```

```c++
template <typename T, typename U>
auto add(T x, U y) -> decltype(x + y) {
    return x + y;
}
```

